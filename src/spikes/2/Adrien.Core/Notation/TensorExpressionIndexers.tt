<#@ assembly name="netstandard.dll" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ assembly name="$(SolutionDir)..\..\..\lib\netstandard2.0\Humanizer.dll" #>
<#@ assembly name="$(TargetDir)Adrien.Core.dll" #>
<#@ import namespace="Adrien.Notation" #>
<#@ output extension=".cs" #>
using System;
using System.Linq.Expressions;

namespace Adrien.Notation
{
	public partial class TensorExpression
	{
		<#for (int i = 1; i <= 8; i++) {#>  
		public TensorExpression this[<#for (int j = 1; j < i; j++) {#>Index index<#=j#>, <#}#>Index index<#=i#>]
		{
			get
			{
				if (this.LinqExpression.NodeType == ExpressionType.Constant &&
                    (this.LinqExpression as ConstantExpression).Type == typeof(Tensor))
                {
                    Tensor t = (this.LinqExpression as ConstantExpression).Value as Tensor;
                    return t[<#for(int j = 1; j < i; j++){#>index<#=j#>, <#}#>index<#=i#>];
                }
                else throw new ArgumentException("This expression is not a tensor;");
			}
			set
			{
				if (this.LinqExpression.NodeType == ExpressionType.Constant &&
                    (this.LinqExpression as ConstantExpression).Type == typeof(Tensor))
                {
                    Tensor t = (this.LinqExpression as ConstantExpression).Value as Tensor;
                    t[<#for(int j = 1; j < i; j++){#>index<#=j#>, <#}#>index<#=i#>] = value;
                }
                else throw new ArgumentException("This expression is not a tensor;");
			}
		}
		<#}#>
	}
}
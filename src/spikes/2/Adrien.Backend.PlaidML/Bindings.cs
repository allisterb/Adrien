// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace Adrien.Backend.PlaidML.Bindings
{
    public enum VaiStatus
    {
        VAI_STATUS_OK = 0,
        VAI_STATUS_CANCELLED = 1,
        VAI_STATUS_UNKNOWN = 2,
        VAI_STATUS_INVALID_ARGUMENT = 3,
        VAI_STATUS_DEADLINE_EXCEEDED = 4,
        VAI_STATUS_NOT_FOUND = 5,
        VAI_STATUS_ALREADY_EXISTS = 6,
        VAI_STATUS_PERMISSION_DENIED = 7,
        VAI_STATUS_RESOURCE_EXHAUSTED = 8,
        VAI_STATUS_FAILED_PRECONDITION = 9,
        VAI_STATUS_ABORTED = 10,
        VAI_STATUS_OUT_OF_RANGE = 11,
        VAI_STATUS_UNIMPLEMENTED = 12,
        VAI_STATUS_INTERNAL = 13,
        VAI_STATUS_UNAVAILABLE = 14,
        VAI_STATUS_DATA_LOSS = 15,
        VAI_STATUS_UNAUTHENTICATED = 16
    }

    public enum VaiLogSeverity
    {
        VAI_LOG_SEVERITY_VERBOSE = 1,
        VAI_LOG_SEVERITY_TRACE = 2,
        VAI_LOG_SEVERITY_DEBUG = 3,
        VAI_LOG_SEVERITY_INFO = 4,
        VAI_LOG_SEVERITY_WARNING = 5,
        VAI_LOG_SEVERITY_ERROR = 6,
        VAI_LOG_SEVERITY_FATAL = 7
    }

    public enum VaiFeatureId
    {
        VAI_FEATURE_ID_RESERVED = 0
    }

    public unsafe partial struct VaiCtx
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        private VaiCtx.__Internal __instance;
        internal VaiCtx.__Internal __Instance { get { return __instance; } }

        internal static global::Adrien.Backend.PlaidML.Bindings.VaiCtx __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.VaiCtx(native.ToPointer(), skipVTables);
        }

        internal static global::Adrien.Backend.PlaidML.Bindings.VaiCtx __CreateInstance(global::Adrien.Backend.PlaidML.Bindings.VaiCtx.__Internal native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.VaiCtx(native, skipVTables);
        }

        private VaiCtx(global::Adrien.Backend.PlaidML.Bindings.VaiCtx.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private VaiCtx(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::Adrien.Backend.PlaidML.Bindings.VaiCtx.__Internal*) native;
        }
    }

    public unsafe partial class @base
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_last_status")]
            internal static extern global::Adrien.Backend.PlaidML.Bindings.VaiStatus VaiLastStatus();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_clear_status")]
            internal static extern void VaiClearStatus();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_last_status_str")]
            internal static extern global::System.IntPtr VaiLastStatusStr();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_set_logger")]
            internal static extern void VaiSetLogger(global::System.IntPtr logger, global::System.IntPtr arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_query_feature")]
            internal static extern global::System.IntPtr VaiQueryFeature(global::Adrien.Backend.PlaidML.Bindings.VaiFeatureId id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_alloc_ctx")]
            internal static extern global::System.IntPtr VaiAllocCtx();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_free_ctx")]
            internal static extern void VaiFreeCtx(global::System.IntPtr ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_cancel_ctx")]
            internal static extern void VaiCancelCtx(global::System.IntPtr ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_set_eventlog")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool VaiSetEventlog(global::System.IntPtr ctx, [MarshalAs(UnmanagedType.LPStr)] string config);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_get_perf_counter")]
            internal static extern long VaiGetPerfCounter([MarshalAs(UnmanagedType.LPStr)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_set_perf_counter")]
            internal static extern void VaiSetPerfCounter([MarshalAs(UnmanagedType.LPStr)] string name, long value);
        }

        public static global::Adrien.Backend.PlaidML.Bindings.VaiStatus VaiLastStatus()
        {
            var __ret = __Internal.VaiLastStatus();
            return __ret;
        }

        public static void VaiClearStatus()
        {
            __Internal.VaiClearStatus();
        }

        public static string VaiLastStatusStr()
        {
            var __ret = __Internal.VaiLastStatusStr();
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static void VaiSetLogger(global::Adrien.Backend.PlaidML.Bindings.Delegates.Action_IntPtr_Adrien_Backend_PlaidML_Bindings_vai_log_severity_string logger, global::System.IntPtr arg)
        {
            var __arg0 = logger == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(logger);
            __Internal.VaiSetLogger(__arg0, arg);
        }

        public static global::System.IntPtr VaiQueryFeature(global::Adrien.Backend.PlaidML.Bindings.VaiFeatureId id)
        {
            var __ret = __Internal.VaiQueryFeature(id);
            return __ret;
        }

        public static global::Adrien.Backend.PlaidML.Bindings.VaiCtx VaiAllocCtx()
        {
            var __ret = __Internal.VaiAllocCtx();
            global::Adrien.Backend.PlaidML.Bindings.VaiCtx __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.VaiCtx();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.VaiCtx.__CreateInstance(__ret);
            return __result0;
        }

        public static void VaiFreeCtx(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            __Internal.VaiFreeCtx(__arg0);
        }

        public static void VaiCancelCtx(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            __Internal.VaiCancelCtx(__arg0);
        }

        public static bool VaiSetEventlog(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx, string config)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __ret = __Internal.VaiSetEventlog(__arg0, config);
            return __ret;
        }

        public static long VaiGetPerfCounter(string name)
        {
            var __ret = __Internal.VaiGetPerfCounter(name);
            return __ret;
        }

        public static void VaiSetPerfCounter(string name, long value)
        {
            __Internal.VaiSetPerfCounter(name, value);
        }
    }

    public enum PlaidmlDeviceProperty
    {
        PLAIDML_DEVICE_ID = 1,
        PLAIDML_DEVICE_CONFIG = 2,
        PLAIDML_DEVICE_DESCRIPTION = 3,
        PLAIDML_DEVICE_DETAILS = 4
    }

    public enum PlaidmlDatatype
    {
        PLAIDML_DATA_INVALID = 0,
        PLAIDML_DATA_BOOLEAN = 2,
        PLAIDML_DATA_INT8 = 16,
        PLAIDML_DATA_INT16 = 17,
        PLAIDML_DATA_INT32 = 18,
        PLAIDML_DATA_INT64 = 19,
        PLAIDML_DATA_UINT8 = 32,
        PLAIDML_DATA_UINT16 = 33,
        PLAIDML_DATA_UINT32 = 34,
        PLAIDML_DATA_UINT64 = 35,
        PLAIDML_DATA_FLOAT16 = 49,
        PLAIDML_DATA_FLOAT32 = 50,
        PLAIDML_DATA_FLOAT64 = 51
    }

    public unsafe partial struct PlaidmlDevconf
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        private PlaidmlDevconf.__Internal __instance;
        internal PlaidmlDevconf.__Internal __Instance { get { return __instance; } }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevconf __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevconf(native.ToPointer(), skipVTables);
        }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevconf __CreateInstance(global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevconf.__Internal native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevconf(native, skipVTables);
        }

        private PlaidmlDevconf(global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevconf.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private PlaidmlDevconf(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevconf.__Internal*) native;
        }
    }

    public unsafe partial struct PlaidmlDevice
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        private PlaidmlDevice.__Internal __instance;
        internal PlaidmlDevice.__Internal __Instance { get { return __instance; } }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevice __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevice(native.ToPointer(), skipVTables);
        }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevice __CreateInstance(global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevice.__Internal native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevice(native, skipVTables);
        }

        private PlaidmlDevice(global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevice.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private PlaidmlDevice(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevice.__Internal*) native;
        }
    }

    public unsafe partial struct PlaidmlDeviceEnumerator
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        private PlaidmlDeviceEnumerator.__Internal __instance;
        internal PlaidmlDeviceEnumerator.__Internal __Instance { get { return __instance; } }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceEnumerator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceEnumerator(native.ToPointer(), skipVTables);
        }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceEnumerator __CreateInstance(global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceEnumerator.__Internal native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceEnumerator(native, skipVTables);
        }

        private PlaidmlDeviceEnumerator(global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceEnumerator.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private PlaidmlDeviceEnumerator(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceEnumerator.__Internal*) native;
        }
    }

    public unsafe partial struct PlaidmlBuffer
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        private PlaidmlBuffer.__Internal __instance;
        internal PlaidmlBuffer.__Internal __Instance { get { return __instance; } }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlBuffer __CreateInstance(global::Adrien.Backend.PlaidML.Bindings.PlaidmlBuffer.__Internal native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlBuffer(native, skipVTables);
        }

        private PlaidmlBuffer(global::Adrien.Backend.PlaidML.Bindings.PlaidmlBuffer.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private PlaidmlBuffer(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::Adrien.Backend.PlaidML.Bindings.PlaidmlBuffer.__Internal*) native;
        }
    }

    public unsafe partial struct PlaidmlMapping
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        private PlaidmlMapping.__Internal __instance;
        internal PlaidmlMapping.__Internal __Instance { get { return __instance; } }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlMapping __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlMapping(native.ToPointer(), skipVTables);
        }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlMapping __CreateInstance(global::Adrien.Backend.PlaidML.Bindings.PlaidmlMapping.__Internal native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlMapping(native, skipVTables);
        }

        private PlaidmlMapping(global::Adrien.Backend.PlaidML.Bindings.PlaidmlMapping.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private PlaidmlMapping(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::Adrien.Backend.PlaidML.Bindings.PlaidmlMapping.__Internal*) native;
        }
    }

    public unsafe partial struct PlaidmlShape
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        private PlaidmlShape.__Internal __instance;
        internal PlaidmlShape.__Internal __Instance { get { return __instance; } }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape(native.ToPointer(), skipVTables);
        }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape __CreateInstance(global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape.__Internal native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape(native, skipVTables);
        }

        private PlaidmlShape(global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private PlaidmlShape(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape.__Internal*) native;
        }
    }

    public unsafe partial struct PlaidmlFunction
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        private PlaidmlFunction.__Internal __instance;
        internal PlaidmlFunction.__Internal __Instance { get { return __instance; } }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction(native.ToPointer(), skipVTables);
        }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction __CreateInstance(global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction.__Internal native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction(native, skipVTables);
        }

        private PlaidmlFunction(global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private PlaidmlFunction(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction.__Internal*) native;
        }
    }

    public unsafe partial struct PlaidmlVar
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        private PlaidmlVar.__Internal __instance;
        internal PlaidmlVar.__Internal __Instance { get { return __instance; } }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar(native.ToPointer(), skipVTables);
        }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar __CreateInstance(global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar.__Internal native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar(native, skipVTables);
        }

        private PlaidmlVar(global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private PlaidmlVar(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar.__Internal*) native;
        }
    }

    public unsafe partial struct PlaidmlApplier
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        private PlaidmlApplier.__Internal __instance;
        internal PlaidmlApplier.__Internal __Instance { get { return __instance; } }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlApplier __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlApplier(native.ToPointer(), skipVTables);
        }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlApplier __CreateInstance(global::Adrien.Backend.PlaidML.Bindings.PlaidmlApplier.__Internal native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlApplier(native, skipVTables);
        }

        private PlaidmlApplier(global::Adrien.Backend.PlaidML.Bindings.PlaidmlApplier.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private PlaidmlApplier(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::Adrien.Backend.PlaidML.Bindings.PlaidmlApplier.__Internal*) native;
        }
    }

    public unsafe partial struct PlaidmlComposer
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        private PlaidmlComposer.__Internal __instance;
        internal PlaidmlComposer.__Internal __Instance { get { return __instance; } }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlComposer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlComposer(native.ToPointer(), skipVTables);
        }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlComposer __CreateInstance(global::Adrien.Backend.PlaidML.Bindings.PlaidmlComposer.__Internal native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlComposer(native, skipVTables);
        }

        private PlaidmlComposer(global::Adrien.Backend.PlaidML.Bindings.PlaidmlComposer.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private PlaidmlComposer(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::Adrien.Backend.PlaidML.Bindings.PlaidmlComposer.__Internal*) native;
        }
    }

    public unsafe partial struct PlaidmlInvoker
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        private PlaidmlInvoker.__Internal __instance;
        internal PlaidmlInvoker.__Internal __Instance { get { return __instance; } }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvoker __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvoker(native.ToPointer(), skipVTables);
        }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvoker __CreateInstance(global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvoker.__Internal native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvoker(native, skipVTables);
        }

        private PlaidmlInvoker(global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvoker.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private PlaidmlInvoker(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvoker.__Internal*) native;
        }
    }

    public unsafe partial class PlaidmlInvocation
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvocation> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvocation>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvocation __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvocation(native.ToPointer(), skipVTables);
        }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvocation __CreateInstance(global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvocation.__Internal native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvocation(native, skipVTables);
        }

        private static void* __CopyValue(global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvocation.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvocation.__Internal));
            *(global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvocation.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PlaidmlInvocation(global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvocation.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PlaidmlInvocation(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial struct PlaidmlGradient
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        private PlaidmlGradient.__Internal __instance;
        internal PlaidmlGradient.__Internal __Instance { get { return __instance; } }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlGradient __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlGradient(native.ToPointer(), skipVTables);
        }

        internal static global::Adrien.Backend.PlaidML.Bindings.PlaidmlGradient __CreateInstance(global::Adrien.Backend.PlaidML.Bindings.PlaidmlGradient.__Internal native, bool skipVTables = false)
        {
            return new global::Adrien.Backend.PlaidML.Bindings.PlaidmlGradient(native, skipVTables);
        }

        private PlaidmlGradient(global::Adrien.Backend.PlaidML.Bindings.PlaidmlGradient.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private PlaidmlGradient(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::Adrien.Backend.PlaidML.Bindings.PlaidmlGradient.__Internal*) native;
        }
    }

    public unsafe partial class plaidml
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_version")]
            internal static extern global::System.IntPtr PlaidmlGetVersion();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_query_devconf")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlQueryDevconf(global::System.IntPtr ctx, global::System.IntPtr devconf, global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceProperty property, global::System.IntPtr output_buffer, ulong output_buffer_size, ulong* output_buffer_size_required);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_open_device")]
            internal static extern global::System.IntPtr PlaidmlOpenDevice(global::System.IntPtr ctx, global::System.IntPtr devconf);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_close_device")]
            internal static extern void PlaidmlCloseDevice(global::System.IntPtr device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_device_enumerator")]
            internal static extern global::System.IntPtr PlaidmlAllocDeviceEnumerator(global::System.IntPtr ctx, global::System.IntPtr callback, global::System.IntPtr arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_device_enumerator_with_config")]
            internal static extern global::System.IntPtr PlaidmlAllocDeviceEnumeratorWithConfig(global::System.IntPtr ctx, [MarshalAs(UnmanagedType.LPStr)] string configuration, global::System.IntPtr callback, global::System.IntPtr arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_device_enumerator")]
            internal static extern void PlaidmlFreeDeviceEnumerator(global::System.IntPtr enumerator);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_enumerator_config_source")]
            internal static extern global::System.IntPtr PlaidmlGetEnumeratorConfigSource(global::System.IntPtr enumerator);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_devconf_count")]
            internal static extern ulong PlaidmlGetDevconfCount(global::System.IntPtr ctx, global::System.IntPtr enumerator, bool valid_devices);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_devconf")]
            internal static extern global::System.IntPtr PlaidmlGetDevconf(global::System.IntPtr ctx, global::System.IntPtr enumerator, ulong index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_invalid_devconf")]
            internal static extern global::System.IntPtr PlaidmlGetInvalidDevconf(global::System.IntPtr ctx, global::System.IntPtr enumerator, ulong index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_buffer")]
            internal static extern global::System.IntPtr PlaidmlAllocBuffer(global::System.IntPtr ctx, global::System.IntPtr device, ulong size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_buffer")]
            internal static extern void PlaidmlFreeBuffer(global::System.IntPtr buffer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_map_buffer_current")]
            internal static extern global::System.IntPtr PlaidmlMapBufferCurrent(global::System.IntPtr buffer, global::System.IntPtr callback, global::System.IntPtr arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_map_buffer_discard")]
            internal static extern global::System.IntPtr PlaidmlMapBufferDiscard(global::System.IntPtr ctx, global::System.IntPtr buffer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_mapping_base")]
            internal static extern sbyte* PlaidmlGetMappingBase(global::System.IntPtr ctx, global::System.IntPtr mapping);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_mapping_size")]
            internal static extern ulong PlaidmlGetMappingSize(global::System.IntPtr ctx, global::System.IntPtr mapping);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_writeback_mapping")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlWritebackMapping(global::System.IntPtr ctx, global::System.IntPtr mapping);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_mapping")]
            internal static extern void PlaidmlFreeMapping(global::System.IntPtr mapping);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_set_floatx")]
            internal static extern void PlaidmlSetFloatx(global::Adrien.Backend.PlaidML.Bindings.PlaidmlDatatype datatype);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_shape")]
            internal static extern global::System.IntPtr PlaidmlAllocShape(global::System.IntPtr ctx, global::Adrien.Backend.PlaidML.Bindings.PlaidmlDatatype datatype);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_shape")]
            internal static extern void PlaidmlFreeShape(global::System.IntPtr shape);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_set_shape_offset")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlSetShapeOffset(global::System.IntPtr ctx, global::System.IntPtr shape, ulong offset_in_elements);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_add_dimension")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlAddDimension(global::System.IntPtr ctx, global::System.IntPtr shape, ulong size_in_elements, long stride_in_elements);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_shape_type")]
            internal static extern global::Adrien.Backend.PlaidML.Bindings.PlaidmlDatatype PlaidmlGetShapeType(global::System.IntPtr shape);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_shape_offset")]
            internal static extern ulong PlaidmlGetShapeOffset(global::System.IntPtr shape);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_shape_dimension_count")]
            internal static extern ulong PlaidmlGetShapeDimensionCount(global::System.IntPtr shape);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_shape_dimension_size")]
            internal static extern ulong PlaidmlGetShapeDimensionSize(global::System.IntPtr shape, ulong dim);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_shape_dimension_stride")]
            internal static extern long PlaidmlGetShapeDimensionStride(global::System.IntPtr shape, ulong dim);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_shape_buffer_size")]
            internal static extern ulong PlaidmlGetShapeBufferSize(global::System.IntPtr shape);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_shape_element_count")]
            internal static extern ulong PlaidmlGetShapeElementCount(global::System.IntPtr shape);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_function")]
            internal static extern void PlaidmlFreeFunction(global::System.IntPtr function);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_function_input_count")]
            internal static extern ulong PlaidmlGetFunctionInputCount(global::System.IntPtr function);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_function_input")]
            internal static extern global::System.IntPtr PlaidmlGetFunctionInput(global::System.IntPtr function, ulong i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_function_output_count")]
            internal static extern ulong PlaidmlGetFunctionOutputCount(global::System.IntPtr function);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_function_output")]
            internal static extern global::System.IntPtr PlaidmlGetFunctionOutput(global::System.IntPtr function, ulong i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_var")]
            internal static extern void PlaidmlFreeVar(global::System.IntPtr var);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_placeholder")]
            internal static extern global::System.IntPtr PlaidmlAllocPlaceholder(ulong num_dimensions);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_int64")]
            internal static extern global::System.IntPtr PlaidmlAllocInt64(long value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_real")]
            internal static extern global::System.IntPtr PlaidmlAllocReal(double value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_tensor")]
            internal static extern global::System.IntPtr PlaidmlAllocTensor(global::System.IntPtr ctx, global::System.IntPtr buffer, global::System.IntPtr shape);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_build_coded_function")]
            internal static extern global::System.IntPtr PlaidmlBuildCodedFunction([MarshalAs(UnmanagedType.LPStr)] string code, [MarshalAs(UnmanagedType.LPStr)] string id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_load_function")]
            internal static extern global::System.IntPtr PlaidmlLoadFunction(global::System.IntPtr ctx, global::System.IntPtr dev, [MarshalAs(UnmanagedType.LPStr)] string file);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_save_function")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlSaveFunction(global::System.IntPtr func, [MarshalAs(UnmanagedType.LPStr)] string file);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_composer")]
            internal static extern global::System.IntPtr PlaidmlAllocComposer();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_add_composer_input")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlAddComposerInput(global::System.IntPtr composer, [MarshalAs(UnmanagedType.LPStr)] string name, global::System.IntPtr var);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_add_composer_output")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlAddComposerOutput(global::System.IntPtr composer, [MarshalAs(UnmanagedType.LPStr)] string name, global::System.IntPtr var);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_add_composer_dependency")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlAddComposerDependency(global::System.IntPtr composer, global::System.IntPtr must_run_before);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_add_composer_update")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlAddComposerUpdate(global::System.IntPtr composer, global::System.IntPtr dest_tensor, global::System.IntPtr src_tensor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_build_composed_function")]
            internal static extern global::System.IntPtr PlaidmlBuildComposedFunction(global::System.IntPtr composer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_composer")]
            internal static extern void PlaidmlFreeComposer(global::System.IntPtr composer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_applier")]
            internal static extern global::System.IntPtr PlaidmlAllocApplier(global::System.IntPtr function);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_apply_add_dependency")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlApplyAddDependency(global::System.IntPtr applier, global::System.IntPtr must_run_before);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_apply_add_input")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlApplyAddInput(global::System.IntPtr applier, [MarshalAs(UnmanagedType.LPStr)] string name, global::System.IntPtr var);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_apply_alloc_output")]
            internal static extern global::System.IntPtr PlaidmlApplyAllocOutput(global::System.IntPtr applier, [MarshalAs(UnmanagedType.LPStr)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_applier")]
            internal static extern void PlaidmlFreeApplier(global::System.IntPtr applier);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_invoker")]
            internal static extern global::System.IntPtr PlaidmlAllocInvoker(global::System.IntPtr ctx, global::System.IntPtr function);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_invoker")]
            internal static extern void PlaidmlFreeInvoker(global::System.IntPtr invoker);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_set_invoker_input")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlSetInvokerInput(global::System.IntPtr invoker, [MarshalAs(UnmanagedType.LPStr)] string name, global::System.IntPtr var);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_invoker_output_shape")]
            internal static extern global::System.IntPtr PlaidmlAllocInvokerOutputShape(global::System.IntPtr invoker, [MarshalAs(UnmanagedType.LPStr)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_set_invoker_output")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlSetInvokerOutput(global::System.IntPtr invoker, [MarshalAs(UnmanagedType.LPStr)] string name, global::System.IntPtr var);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_schedule_invocation")]
            internal static extern global::System.IntPtr PlaidmlScheduleInvocation(global::System.IntPtr ctx, global::System.IntPtr invoker);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_invocation")]
            internal static extern void PlaidmlFreeInvocation(global::System.IntPtr invocation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_gradient")]
            internal static extern global::System.IntPtr PlaidmlAllocGradient(global::System.IntPtr var);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_gradient")]
            internal static extern void PlaidmlFreeGradient(global::System.IntPtr grad);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_compute_grad_wrt")]
            internal static extern global::System.IntPtr PlaidmlComputeGradWrt(global::System.IntPtr grad, global::System.IntPtr wrt);
        }

        public static string PlaidmlGetVersion()
        {
            var __ret = __Internal.PlaidmlGetVersion();
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static bool PlaidmlQueryDevconf(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx, global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevconf devconf, global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceProperty property, global::System.IntPtr output_buffer, ulong output_buffer_size, ref ulong output_buffer_size_required)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg1 = devconf.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            fixed (ulong* __refParamPtr5 = &output_buffer_size_required)
            {
                var __arg5 = __refParamPtr5;
                var __ret = __Internal.PlaidmlQueryDevconf(__arg0, __arg1, property, output_buffer, output_buffer_size, __arg5);
                return __ret;
            }
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevice PlaidmlOpenDevice(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx, global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevconf devconf)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg1 = devconf.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.PlaidmlOpenDevice(__arg0, __arg1);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevice __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevice();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevice.__CreateInstance(__ret);
            return __result0;
        }

        public static void PlaidmlCloseDevice(global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevice device)
        {
            var ____arg0 = device.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            __Internal.PlaidmlCloseDevice(__arg0);
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceEnumerator PlaidmlAllocDeviceEnumerator(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx, global::Adrien.Backend.PlaidML.Bindings.Delegates.Action_IntPtr_IntPtr callback, global::System.IntPtr arg)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.PlaidmlAllocDeviceEnumerator(__arg0, __arg1, arg);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceEnumerator __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceEnumerator();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceEnumerator.__CreateInstance(__ret);
            return __result0;
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceEnumerator PlaidmlAllocDeviceEnumeratorWithConfig(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx, string configuration, global::Adrien.Backend.PlaidML.Bindings.Delegates.Action_IntPtr_IntPtr callback, global::System.IntPtr arg)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __arg2 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.PlaidmlAllocDeviceEnumeratorWithConfig(__arg0, configuration, __arg2, arg);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceEnumerator __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceEnumerator();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceEnumerator.__CreateInstance(__ret);
            return __result0;
        }

        public static void PlaidmlFreeDeviceEnumerator(global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceEnumerator enumerator)
        {
            var ____arg0 = enumerator.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            __Internal.PlaidmlFreeDeviceEnumerator(__arg0);
        }

        public static string PlaidmlGetEnumeratorConfigSource(global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceEnumerator enumerator)
        {
            var ____arg0 = enumerator.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __ret = __Internal.PlaidmlGetEnumeratorConfigSource(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static ulong PlaidmlGetDevconfCount(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx, global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceEnumerator enumerator, bool valid_devices)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg1 = enumerator.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.PlaidmlGetDevconfCount(__arg0, __arg1, valid_devices);
            return __ret;
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevconf PlaidmlGetDevconf(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx, global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceEnumerator enumerator, ulong index)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg1 = enumerator.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.PlaidmlGetDevconf(__arg0, __arg1, index);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevconf __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevconf();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevconf.__CreateInstance(__ret);
            return __result0;
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevconf PlaidmlGetInvalidDevconf(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx, global::Adrien.Backend.PlaidML.Bindings.PlaidmlDeviceEnumerator enumerator, ulong index)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg1 = enumerator.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.PlaidmlGetInvalidDevconf(__arg0, __arg1, index);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevconf __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevconf();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevconf.__CreateInstance(__ret);
            return __result0;
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlBuffer PlaidmlAllocBuffer(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx, global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevice device, ulong size)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg1 = device.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.PlaidmlAllocBuffer(__arg0, __arg1, size);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlBuffer __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlBuffer();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlBuffer.__CreateInstance(__ret);
            return __result0;
        }

        public static void PlaidmlFreeBuffer(global::Adrien.Backend.PlaidML.Bindings.PlaidmlBuffer buffer)
        {
            var ____arg0 = buffer.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            __Internal.PlaidmlFreeBuffer(__arg0);
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlMapping PlaidmlMapBufferCurrent(global::Adrien.Backend.PlaidML.Bindings.PlaidmlBuffer buffer, global::Adrien.Backend.PlaidML.Bindings.Delegates.Action_IntPtr_IntPtr callback, global::System.IntPtr arg)
        {
            var ____arg0 = buffer.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.PlaidmlMapBufferCurrent(__arg0, __arg1, arg);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlMapping __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlMapping();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlMapping.__CreateInstance(__ret);
            return __result0;
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlMapping PlaidmlMapBufferDiscard(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx, global::Adrien.Backend.PlaidML.Bindings.PlaidmlBuffer buffer)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg1 = buffer.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.PlaidmlMapBufferDiscard(__arg0, __arg1);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlMapping __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlMapping();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlMapping.__CreateInstance(__ret);
            return __result0;
        }

        public static sbyte* PlaidmlGetMappingBase(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx, global::Adrien.Backend.PlaidML.Bindings.PlaidmlMapping mapping)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg1 = mapping.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.PlaidmlGetMappingBase(__arg0, __arg1);
            return __ret;
        }

        public static ulong PlaidmlGetMappingSize(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx, global::Adrien.Backend.PlaidML.Bindings.PlaidmlMapping mapping)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg1 = mapping.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.PlaidmlGetMappingSize(__arg0, __arg1);
            return __ret;
        }

        public static bool PlaidmlWritebackMapping(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx, global::Adrien.Backend.PlaidML.Bindings.PlaidmlMapping mapping)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg1 = mapping.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.PlaidmlWritebackMapping(__arg0, __arg1);
            return __ret;
        }

        public static void PlaidmlFreeMapping(global::Adrien.Backend.PlaidML.Bindings.PlaidmlMapping mapping)
        {
            var ____arg0 = mapping.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            __Internal.PlaidmlFreeMapping(__arg0);
        }

        public static void PlaidmlSetFloatx(global::Adrien.Backend.PlaidML.Bindings.PlaidmlDatatype datatype)
        {
            __Internal.PlaidmlSetFloatx(datatype);
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape PlaidmlAllocShape(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx, global::Adrien.Backend.PlaidML.Bindings.PlaidmlDatatype datatype)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __ret = __Internal.PlaidmlAllocShape(__arg0, datatype);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape.__CreateInstance(__ret);
            return __result0;
        }

        public static void PlaidmlFreeShape(global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape shape)
        {
            var ____arg0 = shape.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            __Internal.PlaidmlFreeShape(__arg0);
        }

        public static bool PlaidmlSetShapeOffset(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx, global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape shape, ulong offset_in_elements)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg1 = shape.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.PlaidmlSetShapeOffset(__arg0, __arg1, offset_in_elements);
            return __ret;
        }

        public static bool PlaidmlAddDimension(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx, global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape shape, ulong size_in_elements, long stride_in_elements)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg1 = shape.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.PlaidmlAddDimension(__arg0, __arg1, size_in_elements, stride_in_elements);
            return __ret;
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlDatatype PlaidmlGetShapeType(global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape shape)
        {
            var ____arg0 = shape.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __ret = __Internal.PlaidmlGetShapeType(__arg0);
            return __ret;
        }

        public static ulong PlaidmlGetShapeOffset(global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape shape)
        {
            var ____arg0 = shape.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __ret = __Internal.PlaidmlGetShapeOffset(__arg0);
            return __ret;
        }

        public static ulong PlaidmlGetShapeDimensionCount(global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape shape)
        {
            var ____arg0 = shape.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __ret = __Internal.PlaidmlGetShapeDimensionCount(__arg0);
            return __ret;
        }

        public static ulong PlaidmlGetShapeDimensionSize(global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape shape, ulong dim)
        {
            var ____arg0 = shape.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __ret = __Internal.PlaidmlGetShapeDimensionSize(__arg0, dim);
            return __ret;
        }

        public static long PlaidmlGetShapeDimensionStride(global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape shape, ulong dim)
        {
            var ____arg0 = shape.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __ret = __Internal.PlaidmlGetShapeDimensionStride(__arg0, dim);
            return __ret;
        }

        public static ulong PlaidmlGetShapeBufferSize(global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape shape)
        {
            var ____arg0 = shape.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __ret = __Internal.PlaidmlGetShapeBufferSize(__arg0);
            return __ret;
        }

        public static ulong PlaidmlGetShapeElementCount(global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape shape)
        {
            var ____arg0 = shape.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __ret = __Internal.PlaidmlGetShapeElementCount(__arg0);
            return __ret;
        }

        public static void PlaidmlFreeFunction(global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction function)
        {
            var ____arg0 = function.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            __Internal.PlaidmlFreeFunction(__arg0);
        }

        public static ulong PlaidmlGetFunctionInputCount(global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction function)
        {
            var ____arg0 = function.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __ret = __Internal.PlaidmlGetFunctionInputCount(__arg0);
            return __ret;
        }

        public static string PlaidmlGetFunctionInput(global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction function, ulong i)
        {
            var ____arg0 = function.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __ret = __Internal.PlaidmlGetFunctionInput(__arg0, i);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static ulong PlaidmlGetFunctionOutputCount(global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction function)
        {
            var ____arg0 = function.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __ret = __Internal.PlaidmlGetFunctionOutputCount(__arg0);
            return __ret;
        }

        public static string PlaidmlGetFunctionOutput(global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction function, ulong i)
        {
            var ____arg0 = function.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __ret = __Internal.PlaidmlGetFunctionOutput(__arg0, i);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static void PlaidmlFreeVar(global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar var)
        {
            var ____arg0 = var.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            __Internal.PlaidmlFreeVar(__arg0);
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar PlaidmlAllocPlaceholder(ulong num_dimensions)
        {
            var __ret = __Internal.PlaidmlAllocPlaceholder(num_dimensions);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar.__CreateInstance(__ret);
            return __result0;
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar PlaidmlAllocInt64(long value)
        {
            var __ret = __Internal.PlaidmlAllocInt64(value);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar.__CreateInstance(__ret);
            return __result0;
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar PlaidmlAllocReal(double value)
        {
            var __ret = __Internal.PlaidmlAllocReal(value);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar.__CreateInstance(__ret);
            return __result0;
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar PlaidmlAllocTensor(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx, global::Adrien.Backend.PlaidML.Bindings.PlaidmlBuffer buffer, global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape shape)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg1 = buffer.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var ____arg2 = shape.__Instance;
            var __arg2 = new global::System.IntPtr(&____arg2);
            var __ret = __Internal.PlaidmlAllocTensor(__arg0, __arg1, __arg2);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar.__CreateInstance(__ret);
            return __result0;
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction PlaidmlBuildCodedFunction(string code, string id)
        {
            var __ret = __Internal.PlaidmlBuildCodedFunction(code, id);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction.__CreateInstance(__ret);
            return __result0;
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction PlaidmlLoadFunction(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx, global::Adrien.Backend.PlaidML.Bindings.PlaidmlDevice dev, string file)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg1 = dev.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.PlaidmlLoadFunction(__arg0, __arg1, file);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction.__CreateInstance(__ret);
            return __result0;
        }

        public static bool PlaidmlSaveFunction(global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction func, string file)
        {
            var ____arg0 = func.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __ret = __Internal.PlaidmlSaveFunction(__arg0, file);
            return __ret;
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlComposer PlaidmlAllocComposer()
        {
            var __ret = __Internal.PlaidmlAllocComposer();
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlComposer __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlComposer();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlComposer.__CreateInstance(__ret);
            return __result0;
        }

        public static bool PlaidmlAddComposerInput(global::Adrien.Backend.PlaidML.Bindings.PlaidmlComposer composer, string name, global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar var)
        {
            var ____arg0 = composer.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg2 = var.__Instance;
            var __arg2 = new global::System.IntPtr(&____arg2);
            var __ret = __Internal.PlaidmlAddComposerInput(__arg0, name, __arg2);
            return __ret;
        }

        public static bool PlaidmlAddComposerOutput(global::Adrien.Backend.PlaidML.Bindings.PlaidmlComposer composer, string name, global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar var)
        {
            var ____arg0 = composer.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg2 = var.__Instance;
            var __arg2 = new global::System.IntPtr(&____arg2);
            var __ret = __Internal.PlaidmlAddComposerOutput(__arg0, name, __arg2);
            return __ret;
        }

        public static bool PlaidmlAddComposerDependency(global::Adrien.Backend.PlaidML.Bindings.PlaidmlComposer composer, global::Adrien.Backend.PlaidML.Bindings.PlaidmlApplier must_run_before)
        {
            var ____arg0 = composer.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg1 = must_run_before.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.PlaidmlAddComposerDependency(__arg0, __arg1);
            return __ret;
        }

        public static bool PlaidmlAddComposerUpdate(global::Adrien.Backend.PlaidML.Bindings.PlaidmlComposer composer, global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar dest_tensor, global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar src_tensor)
        {
            var ____arg0 = composer.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg1 = dest_tensor.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var ____arg2 = src_tensor.__Instance;
            var __arg2 = new global::System.IntPtr(&____arg2);
            var __ret = __Internal.PlaidmlAddComposerUpdate(__arg0, __arg1, __arg2);
            return __ret;
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction PlaidmlBuildComposedFunction(global::Adrien.Backend.PlaidML.Bindings.PlaidmlComposer composer)
        {
            var ____arg0 = composer.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __ret = __Internal.PlaidmlBuildComposedFunction(__arg0);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction.__CreateInstance(__ret);
            return __result0;
        }

        public static void PlaidmlFreeComposer(global::Adrien.Backend.PlaidML.Bindings.PlaidmlComposer composer)
        {
            var ____arg0 = composer.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            __Internal.PlaidmlFreeComposer(__arg0);
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlApplier PlaidmlAllocApplier(global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction function)
        {
            var ____arg0 = function.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __ret = __Internal.PlaidmlAllocApplier(__arg0);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlApplier __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlApplier();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlApplier.__CreateInstance(__ret);
            return __result0;
        }

        public static bool PlaidmlApplyAddDependency(global::Adrien.Backend.PlaidML.Bindings.PlaidmlApplier applier, global::Adrien.Backend.PlaidML.Bindings.PlaidmlApplier must_run_before)
        {
            var ____arg0 = applier.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg1 = must_run_before.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.PlaidmlApplyAddDependency(__arg0, __arg1);
            return __ret;
        }

        public static bool PlaidmlApplyAddInput(global::Adrien.Backend.PlaidML.Bindings.PlaidmlApplier applier, string name, global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar var)
        {
            var ____arg0 = applier.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg2 = var.__Instance;
            var __arg2 = new global::System.IntPtr(&____arg2);
            var __ret = __Internal.PlaidmlApplyAddInput(__arg0, name, __arg2);
            return __ret;
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar PlaidmlApplyAllocOutput(global::Adrien.Backend.PlaidML.Bindings.PlaidmlApplier applier, string name)
        {
            var ____arg0 = applier.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __ret = __Internal.PlaidmlApplyAllocOutput(__arg0, name);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar.__CreateInstance(__ret);
            return __result0;
        }

        public static void PlaidmlFreeApplier(global::Adrien.Backend.PlaidML.Bindings.PlaidmlApplier applier)
        {
            var ____arg0 = applier.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            __Internal.PlaidmlFreeApplier(__arg0);
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvoker PlaidmlAllocInvoker(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx, global::Adrien.Backend.PlaidML.Bindings.PlaidmlFunction function)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg1 = function.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.PlaidmlAllocInvoker(__arg0, __arg1);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvoker __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvoker();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvoker.__CreateInstance(__ret);
            return __result0;
        }

        public static void PlaidmlFreeInvoker(global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvoker invoker)
        {
            var ____arg0 = invoker.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            __Internal.PlaidmlFreeInvoker(__arg0);
        }

        public static bool PlaidmlSetInvokerInput(global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvoker invoker, string name, global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar var)
        {
            var ____arg0 = invoker.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg2 = var.__Instance;
            var __arg2 = new global::System.IntPtr(&____arg2);
            var __ret = __Internal.PlaidmlSetInvokerInput(__arg0, name, __arg2);
            return __ret;
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape PlaidmlAllocInvokerOutputShape(global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvoker invoker, string name)
        {
            var ____arg0 = invoker.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __ret = __Internal.PlaidmlAllocInvokerOutputShape(__arg0, name);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlShape.__CreateInstance(__ret);
            return __result0;
        }

        public static bool PlaidmlSetInvokerOutput(global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvoker invoker, string name, global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar var)
        {
            var ____arg0 = invoker.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg2 = var.__Instance;
            var __arg2 = new global::System.IntPtr(&____arg2);
            var __ret = __Internal.PlaidmlSetInvokerOutput(__arg0, name, __arg2);
            return __ret;
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvocation PlaidmlScheduleInvocation(global::Adrien.Backend.PlaidML.Bindings.VaiCtx ctx, global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvoker invoker)
        {
            var ____arg0 = ctx.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg1 = invoker.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.PlaidmlScheduleInvocation(__arg0, __arg1);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvocation __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvocation.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvocation) global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvocation.NativeToManagedMap[__ret];
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvocation.__CreateInstance(__ret);
            return __result0;
        }

        public static void PlaidmlFreeInvocation(global::Adrien.Backend.PlaidML.Bindings.PlaidmlInvocation invocation)
        {
            var __arg0 = ReferenceEquals(invocation, null) ? global::System.IntPtr.Zero : invocation.__Instance;
            __Internal.PlaidmlFreeInvocation(__arg0);
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlGradient PlaidmlAllocGradient(global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar var)
        {
            var ____arg0 = var.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __ret = __Internal.PlaidmlAllocGradient(__arg0);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlGradient __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlGradient();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlGradient.__CreateInstance(__ret);
            return __result0;
        }

        public static void PlaidmlFreeGradient(global::Adrien.Backend.PlaidML.Bindings.PlaidmlGradient grad)
        {
            var ____arg0 = grad.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            __Internal.PlaidmlFreeGradient(__arg0);
        }

        public static global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar PlaidmlComputeGradWrt(global::Adrien.Backend.PlaidML.Bindings.PlaidmlGradient grad, global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar wrt)
        {
            var ____arg0 = grad.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg1 = wrt.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.PlaidmlComputeGradWrt(__arg0, __arg1);
            global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar __result0;
            if (__ret == IntPtr.Zero) __result0 = new global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar();
            else __result0 = global::Adrien.Backend.PlaidML.Bindings.PlaidmlVar.__CreateInstance(__ret);
            return __result0;
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_Adrien_Backend_PlaidML_Bindings_vai_log_severity_string(global::System.IntPtr _0, global::Adrien.Backend.PlaidML.Bindings.VaiLogSeverity _1, [MarshalAs(UnmanagedType.LPStr)] string _2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_IntPtr(global::System.IntPtr _0, global::System.IntPtr _1);
    }
}

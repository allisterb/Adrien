// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace PlaidML
{
    public enum VaiStatus
    {
        VAI_STATUS_OK = 0,
        VAI_STATUS_CANCELLED = 1,
        VAI_STATUS_UNKNOWN = 2,
        VAI_STATUS_INVALID_ARGUMENT = 3,
        VAI_STATUS_DEADLINE_EXCEEDED = 4,
        VAI_STATUS_NOT_FOUND = 5,
        VAI_STATUS_ALREADY_EXISTS = 6,
        VAI_STATUS_PERMISSION_DENIED = 7,
        VAI_STATUS_RESOURCE_EXHAUSTED = 8,
        VAI_STATUS_FAILED_PRECONDITION = 9,
        VAI_STATUS_ABORTED = 10,
        VAI_STATUS_OUT_OF_RANGE = 11,
        VAI_STATUS_UNIMPLEMENTED = 12,
        VAI_STATUS_INTERNAL = 13,
        VAI_STATUS_UNAVAILABLE = 14,
        VAI_STATUS_DATA_LOSS = 15,
        VAI_STATUS_UNAUTHENTICATED = 16
    }

    public enum VaiLogSeverity
    {
        VAI_LOG_SEVERITY_VERBOSE = 1,
        VAI_LOG_SEVERITY_TRACE = 2,
        VAI_LOG_SEVERITY_DEBUG = 3,
        VAI_LOG_SEVERITY_INFO = 4,
        VAI_LOG_SEVERITY_WARNING = 5,
        VAI_LOG_SEVERITY_ERROR = 6,
        VAI_LOG_SEVERITY_FATAL = 7
    }

    public enum VaiFeatureId
    {
        VAI_FEATURE_ID_RESERVED = 0
    }

    public unsafe partial class VaiCtx
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.VaiCtx> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.VaiCtx>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::PlaidML.VaiCtx __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PlaidML.VaiCtx(native.ToPointer(), skipVTables);
        }

        internal static global::PlaidML.VaiCtx __CreateInstance(global::PlaidML.VaiCtx.__Internal native, bool skipVTables = false)
        {
            return new global::PlaidML.VaiCtx(native, skipVTables);
        }

        private static void* __CopyValue(global::PlaidML.VaiCtx.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PlaidML.VaiCtx.__Internal));
            *(global::PlaidML.VaiCtx.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VaiCtx(global::PlaidML.VaiCtx.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VaiCtx(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class @base
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_last_status")]
            internal static extern global::PlaidML.VaiStatus VaiLastStatus();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_clear_status")]
            internal static extern void VaiClearStatus();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_last_status_str")]
            internal static extern global::System.IntPtr VaiLastStatusStr();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_set_logger")]
            internal static extern void VaiSetLogger(global::System.IntPtr logger, global::System.IntPtr arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_query_feature")]
            internal static extern global::System.IntPtr VaiQueryFeature(global::PlaidML.VaiFeatureId id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_alloc_ctx")]
            internal static extern global::System.IntPtr VaiAllocCtx();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_free_ctx")]
            internal static extern void VaiFreeCtx(global::System.IntPtr ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_cancel_ctx")]
            internal static extern void VaiCancelCtx(global::System.IntPtr ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_set_eventlog")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool VaiSetEventlog(global::System.IntPtr ctx, [MarshalAs(UnmanagedType.LPStr)] string config);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_get_perf_counter")]
            internal static extern long VaiGetPerfCounter([MarshalAs(UnmanagedType.LPStr)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vai_set_perf_counter")]
            internal static extern void VaiSetPerfCounter([MarshalAs(UnmanagedType.LPStr)] string name, long value);
        }

        public static global::PlaidML.VaiStatus VaiLastStatus()
        {
            var __ret = __Internal.VaiLastStatus();
            return __ret;
        }

        public static void VaiClearStatus()
        {
            __Internal.VaiClearStatus();
        }

        public static string VaiLastStatusStr()
        {
            var __ret = __Internal.VaiLastStatusStr();
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static void VaiSetLogger(global::PlaidML.Delegates.Action_IntPtr_PlaidML_vai_log_severity_string logger, global::System.IntPtr arg)
        {
            var __arg0 = logger == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(logger);
            __Internal.VaiSetLogger(__arg0, arg);
        }

        public static global::System.IntPtr VaiQueryFeature(global::PlaidML.VaiFeatureId id)
        {
            var __ret = __Internal.VaiQueryFeature(id);
            return __ret;
        }

        public static global::PlaidML.VaiCtx VaiAllocCtx()
        {
            var __ret = __Internal.VaiAllocCtx();
            global::PlaidML.VaiCtx __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.VaiCtx.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.VaiCtx) global::PlaidML.VaiCtx.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.VaiCtx.__CreateInstance(__ret);
            return __result0;
        }

        public static void VaiFreeCtx(global::PlaidML.VaiCtx ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            __Internal.VaiFreeCtx(__arg0);
        }

        public static void VaiCancelCtx(global::PlaidML.VaiCtx ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            __Internal.VaiCancelCtx(__arg0);
        }

        public static bool VaiSetEventlog(global::PlaidML.VaiCtx ctx, string config)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.VaiSetEventlog(__arg0, config);
            return __ret;
        }

        public static long VaiGetPerfCounter(string name)
        {
            var __ret = __Internal.VaiGetPerfCounter(name);
            return __ret;
        }

        public static void VaiSetPerfCounter(string name, long value)
        {
            __Internal.VaiSetPerfCounter(name, value);
        }
    }

    public enum PlaidmlDeviceProperty
    {
        PLAIDML_DEVICE_ID = 1,
        PLAIDML_DEVICE_CONFIG = 2,
        PLAIDML_DEVICE_DESCRIPTION = 3,
        PLAIDML_DEVICE_DETAILS = 4
    }

    public enum PlaidmlDatatype
    {
        PLAIDML_DATA_INVALID = 0,
        PLAIDML_DATA_BOOLEAN = 2,
        PLAIDML_DATA_INT8 = 16,
        PLAIDML_DATA_INT16 = 17,
        PLAIDML_DATA_INT32 = 18,
        PLAIDML_DATA_INT64 = 19,
        PLAIDML_DATA_UINT8 = 32,
        PLAIDML_DATA_UINT16 = 33,
        PLAIDML_DATA_UINT32 = 34,
        PLAIDML_DATA_UINT64 = 35,
        PLAIDML_DATA_FLOAT16 = 49,
        PLAIDML_DATA_FLOAT32 = 50,
        PLAIDML_DATA_FLOAT64 = 51
    }

    public unsafe partial class PlaidmlDevconf
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlDevconf> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlDevconf>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::PlaidML.PlaidmlDevconf __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlDevconf(native.ToPointer(), skipVTables);
        }

        internal static global::PlaidML.PlaidmlDevconf __CreateInstance(global::PlaidML.PlaidmlDevconf.__Internal native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlDevconf(native, skipVTables);
        }

        private static void* __CopyValue(global::PlaidML.PlaidmlDevconf.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PlaidML.PlaidmlDevconf.__Internal));
            *(global::PlaidML.PlaidmlDevconf.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PlaidmlDevconf(global::PlaidML.PlaidmlDevconf.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PlaidmlDevconf(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class PlaidmlDevice
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlDevice> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlDevice>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::PlaidML.PlaidmlDevice __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlDevice(native.ToPointer(), skipVTables);
        }

        internal static global::PlaidML.PlaidmlDevice __CreateInstance(global::PlaidML.PlaidmlDevice.__Internal native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlDevice(native, skipVTables);
        }

        private static void* __CopyValue(global::PlaidML.PlaidmlDevice.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PlaidML.PlaidmlDevice.__Internal));
            *(global::PlaidML.PlaidmlDevice.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PlaidmlDevice(global::PlaidML.PlaidmlDevice.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PlaidmlDevice(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class PlaidmlDeviceEnumerator
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlDeviceEnumerator> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlDeviceEnumerator>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::PlaidML.PlaidmlDeviceEnumerator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlDeviceEnumerator(native.ToPointer(), skipVTables);
        }

        internal static global::PlaidML.PlaidmlDeviceEnumerator __CreateInstance(global::PlaidML.PlaidmlDeviceEnumerator.__Internal native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlDeviceEnumerator(native, skipVTables);
        }

        private static void* __CopyValue(global::PlaidML.PlaidmlDeviceEnumerator.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PlaidML.PlaidmlDeviceEnumerator.__Internal));
            *(global::PlaidML.PlaidmlDeviceEnumerator.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PlaidmlDeviceEnumerator(global::PlaidML.PlaidmlDeviceEnumerator.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PlaidmlDeviceEnumerator(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class PlaidmlBuffer
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlBuffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlBuffer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::PlaidML.PlaidmlBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::PlaidML.PlaidmlBuffer __CreateInstance(global::PlaidML.PlaidmlBuffer.__Internal native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlBuffer(native, skipVTables);
        }

        private static void* __CopyValue(global::PlaidML.PlaidmlBuffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PlaidML.PlaidmlBuffer.__Internal));
            *(global::PlaidML.PlaidmlBuffer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PlaidmlBuffer(global::PlaidML.PlaidmlBuffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PlaidmlBuffer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class PlaidmlMapping
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlMapping> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlMapping>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::PlaidML.PlaidmlMapping __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlMapping(native.ToPointer(), skipVTables);
        }

        internal static global::PlaidML.PlaidmlMapping __CreateInstance(global::PlaidML.PlaidmlMapping.__Internal native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlMapping(native, skipVTables);
        }

        private static void* __CopyValue(global::PlaidML.PlaidmlMapping.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PlaidML.PlaidmlMapping.__Internal));
            *(global::PlaidML.PlaidmlMapping.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PlaidmlMapping(global::PlaidML.PlaidmlMapping.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PlaidmlMapping(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class PlaidmlShape
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlShape> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlShape>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::PlaidML.PlaidmlShape __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlShape(native.ToPointer(), skipVTables);
        }

        internal static global::PlaidML.PlaidmlShape __CreateInstance(global::PlaidML.PlaidmlShape.__Internal native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlShape(native, skipVTables);
        }

        private static void* __CopyValue(global::PlaidML.PlaidmlShape.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PlaidML.PlaidmlShape.__Internal));
            *(global::PlaidML.PlaidmlShape.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PlaidmlShape(global::PlaidML.PlaidmlShape.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PlaidmlShape(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class PlaidmlFunction
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlFunction> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlFunction>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::PlaidML.PlaidmlFunction __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlFunction(native.ToPointer(), skipVTables);
        }

        internal static global::PlaidML.PlaidmlFunction __CreateInstance(global::PlaidML.PlaidmlFunction.__Internal native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlFunction(native, skipVTables);
        }

        private static void* __CopyValue(global::PlaidML.PlaidmlFunction.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PlaidML.PlaidmlFunction.__Internal));
            *(global::PlaidML.PlaidmlFunction.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PlaidmlFunction(global::PlaidML.PlaidmlFunction.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PlaidmlFunction(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class PlaidmlVar
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlVar> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlVar>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::PlaidML.PlaidmlVar __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlVar(native.ToPointer(), skipVTables);
        }

        internal static global::PlaidML.PlaidmlVar __CreateInstance(global::PlaidML.PlaidmlVar.__Internal native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlVar(native, skipVTables);
        }

        private static void* __CopyValue(global::PlaidML.PlaidmlVar.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PlaidML.PlaidmlVar.__Internal));
            *(global::PlaidML.PlaidmlVar.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PlaidmlVar(global::PlaidML.PlaidmlVar.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PlaidmlVar(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class PlaidmlApplier
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlApplier> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlApplier>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::PlaidML.PlaidmlApplier __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlApplier(native.ToPointer(), skipVTables);
        }

        internal static global::PlaidML.PlaidmlApplier __CreateInstance(global::PlaidML.PlaidmlApplier.__Internal native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlApplier(native, skipVTables);
        }

        private static void* __CopyValue(global::PlaidML.PlaidmlApplier.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PlaidML.PlaidmlApplier.__Internal));
            *(global::PlaidML.PlaidmlApplier.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PlaidmlApplier(global::PlaidML.PlaidmlApplier.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PlaidmlApplier(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class PlaidmlComposer
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlComposer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlComposer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::PlaidML.PlaidmlComposer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlComposer(native.ToPointer(), skipVTables);
        }

        internal static global::PlaidML.PlaidmlComposer __CreateInstance(global::PlaidML.PlaidmlComposer.__Internal native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlComposer(native, skipVTables);
        }

        private static void* __CopyValue(global::PlaidML.PlaidmlComposer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PlaidML.PlaidmlComposer.__Internal));
            *(global::PlaidML.PlaidmlComposer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PlaidmlComposer(global::PlaidML.PlaidmlComposer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PlaidmlComposer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class PlaidmlInvoker
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlInvoker> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlInvoker>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::PlaidML.PlaidmlInvoker __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlInvoker(native.ToPointer(), skipVTables);
        }

        internal static global::PlaidML.PlaidmlInvoker __CreateInstance(global::PlaidML.PlaidmlInvoker.__Internal native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlInvoker(native, skipVTables);
        }

        private static void* __CopyValue(global::PlaidML.PlaidmlInvoker.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PlaidML.PlaidmlInvoker.__Internal));
            *(global::PlaidML.PlaidmlInvoker.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PlaidmlInvoker(global::PlaidML.PlaidmlInvoker.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PlaidmlInvoker(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class PlaidmlInvocation
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlInvocation> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlInvocation>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::PlaidML.PlaidmlInvocation __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlInvocation(native.ToPointer(), skipVTables);
        }

        internal static global::PlaidML.PlaidmlInvocation __CreateInstance(global::PlaidML.PlaidmlInvocation.__Internal native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlInvocation(native, skipVTables);
        }

        private static void* __CopyValue(global::PlaidML.PlaidmlInvocation.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PlaidML.PlaidmlInvocation.__Internal));
            *(global::PlaidML.PlaidmlInvocation.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PlaidmlInvocation(global::PlaidML.PlaidmlInvocation.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PlaidmlInvocation(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class PlaidmlGradient
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlGradient> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PlaidML.PlaidmlGradient>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::PlaidML.PlaidmlGradient __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlGradient(native.ToPointer(), skipVTables);
        }

        internal static global::PlaidML.PlaidmlGradient __CreateInstance(global::PlaidML.PlaidmlGradient.__Internal native, bool skipVTables = false)
        {
            return new global::PlaidML.PlaidmlGradient(native, skipVTables);
        }

        private static void* __CopyValue(global::PlaidML.PlaidmlGradient.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PlaidML.PlaidmlGradient.__Internal));
            *(global::PlaidML.PlaidmlGradient.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PlaidmlGradient(global::PlaidML.PlaidmlGradient.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PlaidmlGradient(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class plaidml
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_version")]
            internal static extern global::System.IntPtr PlaidmlGetVersion();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_query_devconf")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlQueryDevconf(global::System.IntPtr ctx, global::System.IntPtr devconf, global::PlaidML.PlaidmlDeviceProperty property, global::System.IntPtr output_buffer, ulong output_buffer_size, ulong* output_buffer_size_required);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_open_device")]
            internal static extern global::System.IntPtr PlaidmlOpenDevice(global::System.IntPtr ctx, global::System.IntPtr devconf);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_close_device")]
            internal static extern void PlaidmlCloseDevice(global::System.IntPtr device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_device_enumerator")]
            internal static extern global::System.IntPtr PlaidmlAllocDeviceEnumerator(global::System.IntPtr ctx, global::System.IntPtr callback, global::System.IntPtr arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_device_enumerator_with_config")]
            internal static extern global::System.IntPtr PlaidmlAllocDeviceEnumeratorWithConfig(global::System.IntPtr ctx, [MarshalAs(UnmanagedType.LPStr)] string configuration, global::System.IntPtr callback, global::System.IntPtr arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_device_enumerator")]
            internal static extern void PlaidmlFreeDeviceEnumerator(global::System.IntPtr enumerator);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_enumerator_config_source")]
            internal static extern global::System.IntPtr PlaidmlGetEnumeratorConfigSource(global::System.IntPtr enumerator);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_devconf_count")]
            internal static extern ulong PlaidmlGetDevconfCount(global::System.IntPtr ctx, global::System.IntPtr enumerator, bool valid_devices);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_devconf")]
            internal static extern global::System.IntPtr PlaidmlGetDevconf(global::System.IntPtr ctx, global::System.IntPtr enumerator, ulong index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_invalid_devconf")]
            internal static extern global::System.IntPtr PlaidmlGetInvalidDevconf(global::System.IntPtr ctx, global::System.IntPtr enumerator, ulong index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_buffer")]
            internal static extern global::System.IntPtr PlaidmlAllocBuffer(global::System.IntPtr ctx, global::System.IntPtr device, ulong size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_buffer")]
            internal static extern void PlaidmlFreeBuffer(global::System.IntPtr buffer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_map_buffer_current")]
            internal static extern global::System.IntPtr PlaidmlMapBufferCurrent(global::System.IntPtr buffer, global::System.IntPtr callback, global::System.IntPtr arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_map_buffer_discard")]
            internal static extern global::System.IntPtr PlaidmlMapBufferDiscard(global::System.IntPtr ctx, global::System.IntPtr buffer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_mapping_base")]
            internal static extern sbyte* PlaidmlGetMappingBase(global::System.IntPtr ctx, global::System.IntPtr mapping);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_mapping_size")]
            internal static extern ulong PlaidmlGetMappingSize(global::System.IntPtr ctx, global::System.IntPtr mapping);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_writeback_mapping")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlWritebackMapping(global::System.IntPtr ctx, global::System.IntPtr mapping);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_mapping")]
            internal static extern void PlaidmlFreeMapping(global::System.IntPtr mapping);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_set_floatx")]
            internal static extern void PlaidmlSetFloatx(global::PlaidML.PlaidmlDatatype datatype);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_shape")]
            internal static extern global::System.IntPtr PlaidmlAllocShape(global::System.IntPtr ctx, global::PlaidML.PlaidmlDatatype datatype);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_shape")]
            internal static extern void PlaidmlFreeShape(global::System.IntPtr shape);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_set_shape_offset")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlSetShapeOffset(global::System.IntPtr ctx, global::System.IntPtr shape, ulong offset_in_elements);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_add_dimension")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlAddDimension(global::System.IntPtr ctx, global::System.IntPtr shape, ulong size_in_elements, long stride_in_elements);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_shape_type")]
            internal static extern global::PlaidML.PlaidmlDatatype PlaidmlGetShapeType(global::System.IntPtr shape);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_shape_offset")]
            internal static extern ulong PlaidmlGetShapeOffset(global::System.IntPtr shape);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_shape_dimension_count")]
            internal static extern ulong PlaidmlGetShapeDimensionCount(global::System.IntPtr shape);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_shape_dimension_size")]
            internal static extern ulong PlaidmlGetShapeDimensionSize(global::System.IntPtr shape, ulong dim);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_shape_dimension_stride")]
            internal static extern long PlaidmlGetShapeDimensionStride(global::System.IntPtr shape, ulong dim);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_shape_buffer_size")]
            internal static extern ulong PlaidmlGetShapeBufferSize(global::System.IntPtr shape);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_shape_element_count")]
            internal static extern ulong PlaidmlGetShapeElementCount(global::System.IntPtr shape);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_function")]
            internal static extern void PlaidmlFreeFunction(global::System.IntPtr function);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_function_input_count")]
            internal static extern ulong PlaidmlGetFunctionInputCount(global::System.IntPtr function);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_function_input")]
            internal static extern global::System.IntPtr PlaidmlGetFunctionInput(global::System.IntPtr function, ulong i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_function_output_count")]
            internal static extern ulong PlaidmlGetFunctionOutputCount(global::System.IntPtr function);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_get_function_output")]
            internal static extern global::System.IntPtr PlaidmlGetFunctionOutput(global::System.IntPtr function, ulong i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_var")]
            internal static extern void PlaidmlFreeVar(global::System.IntPtr var);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_placeholder")]
            internal static extern global::System.IntPtr PlaidmlAllocPlaceholder(ulong num_dimensions);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_int64")]
            internal static extern global::System.IntPtr PlaidmlAllocInt64(long value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_real")]
            internal static extern global::System.IntPtr PlaidmlAllocReal(double value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_tensor")]
            internal static extern global::System.IntPtr PlaidmlAllocTensor(global::System.IntPtr ctx, global::System.IntPtr buffer, global::System.IntPtr shape);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_build_coded_function")]
            internal static extern global::System.IntPtr PlaidmlBuildCodedFunction([MarshalAs(UnmanagedType.LPStr)] string code, [MarshalAs(UnmanagedType.LPStr)] string id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_load_function")]
            internal static extern global::System.IntPtr PlaidmlLoadFunction(global::System.IntPtr ctx, global::System.IntPtr dev, [MarshalAs(UnmanagedType.LPStr)] string file);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_save_function")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlSaveFunction(global::System.IntPtr func, [MarshalAs(UnmanagedType.LPStr)] string file);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_composer")]
            internal static extern global::System.IntPtr PlaidmlAllocComposer();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_add_composer_input")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlAddComposerInput(global::System.IntPtr composer, [MarshalAs(UnmanagedType.LPStr)] string name, global::System.IntPtr var);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_add_composer_output")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlAddComposerOutput(global::System.IntPtr composer, [MarshalAs(UnmanagedType.LPStr)] string name, global::System.IntPtr var);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_add_composer_dependency")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlAddComposerDependency(global::System.IntPtr composer, global::System.IntPtr must_run_before);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_add_composer_update")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlAddComposerUpdate(global::System.IntPtr composer, global::System.IntPtr dest_tensor, global::System.IntPtr src_tensor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_build_composed_function")]
            internal static extern global::System.IntPtr PlaidmlBuildComposedFunction(global::System.IntPtr composer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_composer")]
            internal static extern void PlaidmlFreeComposer(global::System.IntPtr composer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_applier")]
            internal static extern global::System.IntPtr PlaidmlAllocApplier(global::System.IntPtr function);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_apply_add_dependency")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlApplyAddDependency(global::System.IntPtr applier, global::System.IntPtr must_run_before);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_apply_add_input")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlApplyAddInput(global::System.IntPtr applier, [MarshalAs(UnmanagedType.LPStr)] string name, global::System.IntPtr var);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_apply_alloc_output")]
            internal static extern global::System.IntPtr PlaidmlApplyAllocOutput(global::System.IntPtr applier, [MarshalAs(UnmanagedType.LPStr)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_applier")]
            internal static extern void PlaidmlFreeApplier(global::System.IntPtr applier);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_invoker")]
            internal static extern global::System.IntPtr PlaidmlAllocInvoker(global::System.IntPtr ctx, global::System.IntPtr function);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_invoker")]
            internal static extern void PlaidmlFreeInvoker(global::System.IntPtr invoker);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_set_invoker_input")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlSetInvokerInput(global::System.IntPtr invoker, [MarshalAs(UnmanagedType.LPStr)] string name, global::System.IntPtr var);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_invoker_output_shape")]
            internal static extern global::System.IntPtr PlaidmlAllocInvokerOutputShape(global::System.IntPtr invoker, [MarshalAs(UnmanagedType.LPStr)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_set_invoker_output")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PlaidmlSetInvokerOutput(global::System.IntPtr invoker, [MarshalAs(UnmanagedType.LPStr)] string name, global::System.IntPtr var);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_schedule_invocation")]
            internal static extern global::System.IntPtr PlaidmlScheduleInvocation(global::System.IntPtr ctx, global::System.IntPtr invoker);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_invocation")]
            internal static extern void PlaidmlFreeInvocation(global::System.IntPtr invocation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_alloc_gradient")]
            internal static extern global::System.IntPtr PlaidmlAllocGradient(global::System.IntPtr var);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_free_gradient")]
            internal static extern void PlaidmlFreeGradient(global::System.IntPtr grad);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("plaidml", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="plaidml_compute_grad_wrt")]
            internal static extern global::System.IntPtr PlaidmlComputeGradWrt(global::System.IntPtr grad, global::System.IntPtr wrt);
        }

        public static string PlaidmlGetVersion()
        {
            var __ret = __Internal.PlaidmlGetVersion();
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static bool PlaidmlQueryDevconf(global::PlaidML.VaiCtx ctx, global::PlaidML.PlaidmlDevconf devconf, global::PlaidML.PlaidmlDeviceProperty property, global::System.IntPtr output_buffer, ulong output_buffer_size, ref ulong output_buffer_size_required)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(devconf, null) ? global::System.IntPtr.Zero : devconf.__Instance;
            fixed (ulong* __refParamPtr5 = &output_buffer_size_required)
            {
                var __arg5 = __refParamPtr5;
                var __ret = __Internal.PlaidmlQueryDevconf(__arg0, __arg1, property, output_buffer, output_buffer_size, __arg5);
                return __ret;
            }
        }

        public static global::PlaidML.PlaidmlDevice PlaidmlOpenDevice(global::PlaidML.VaiCtx ctx, global::PlaidML.PlaidmlDevconf devconf)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(devconf, null) ? global::System.IntPtr.Zero : devconf.__Instance;
            var __ret = __Internal.PlaidmlOpenDevice(__arg0, __arg1);
            global::PlaidML.PlaidmlDevice __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlDevice.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlDevice) global::PlaidML.PlaidmlDevice.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlDevice.__CreateInstance(__ret);
            return __result0;
        }

        public static void PlaidmlCloseDevice(global::PlaidML.PlaidmlDevice device)
        {
            var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
            __Internal.PlaidmlCloseDevice(__arg0);
        }

        public static global::PlaidML.PlaidmlDeviceEnumerator PlaidmlAllocDeviceEnumerator(global::PlaidML.VaiCtx ctx, global::PlaidML.Delegates.Action_IntPtr_IntPtr callback, global::System.IntPtr arg)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.PlaidmlAllocDeviceEnumerator(__arg0, __arg1, arg);
            global::PlaidML.PlaidmlDeviceEnumerator __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlDeviceEnumerator.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlDeviceEnumerator) global::PlaidML.PlaidmlDeviceEnumerator.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlDeviceEnumerator.__CreateInstance(__ret);
            return __result0;
        }

        public static global::PlaidML.PlaidmlDeviceEnumerator PlaidmlAllocDeviceEnumeratorWithConfig(global::PlaidML.VaiCtx ctx, string configuration, global::PlaidML.Delegates.Action_IntPtr_IntPtr callback, global::System.IntPtr arg)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg2 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.PlaidmlAllocDeviceEnumeratorWithConfig(__arg0, configuration, __arg2, arg);
            global::PlaidML.PlaidmlDeviceEnumerator __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlDeviceEnumerator.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlDeviceEnumerator) global::PlaidML.PlaidmlDeviceEnumerator.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlDeviceEnumerator.__CreateInstance(__ret);
            return __result0;
        }

        public static void PlaidmlFreeDeviceEnumerator(global::PlaidML.PlaidmlDeviceEnumerator enumerator)
        {
            var __arg0 = ReferenceEquals(enumerator, null) ? global::System.IntPtr.Zero : enumerator.__Instance;
            __Internal.PlaidmlFreeDeviceEnumerator(__arg0);
        }

        public static string PlaidmlGetEnumeratorConfigSource(global::PlaidML.PlaidmlDeviceEnumerator enumerator)
        {
            var __arg0 = ReferenceEquals(enumerator, null) ? global::System.IntPtr.Zero : enumerator.__Instance;
            var __ret = __Internal.PlaidmlGetEnumeratorConfigSource(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static ulong PlaidmlGetDevconfCount(global::PlaidML.VaiCtx ctx, global::PlaidML.PlaidmlDeviceEnumerator enumerator, bool valid_devices)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(enumerator, null) ? global::System.IntPtr.Zero : enumerator.__Instance;
            var __ret = __Internal.PlaidmlGetDevconfCount(__arg0, __arg1, valid_devices);
            return __ret;
        }

        public static global::PlaidML.PlaidmlDevconf PlaidmlGetDevconf(global::PlaidML.VaiCtx ctx, global::PlaidML.PlaidmlDeviceEnumerator enumerator, ulong index)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(enumerator, null) ? global::System.IntPtr.Zero : enumerator.__Instance;
            var __ret = __Internal.PlaidmlGetDevconf(__arg0, __arg1, index);
            global::PlaidML.PlaidmlDevconf __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlDevconf.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlDevconf) global::PlaidML.PlaidmlDevconf.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlDevconf.__CreateInstance(__ret);
            return __result0;
        }

        public static global::PlaidML.PlaidmlDevconf PlaidmlGetInvalidDevconf(global::PlaidML.VaiCtx ctx, global::PlaidML.PlaidmlDeviceEnumerator enumerator, ulong index)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(enumerator, null) ? global::System.IntPtr.Zero : enumerator.__Instance;
            var __ret = __Internal.PlaidmlGetInvalidDevconf(__arg0, __arg1, index);
            global::PlaidML.PlaidmlDevconf __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlDevconf.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlDevconf) global::PlaidML.PlaidmlDevconf.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlDevconf.__CreateInstance(__ret);
            return __result0;
        }

        public static global::PlaidML.PlaidmlBuffer PlaidmlAllocBuffer(global::PlaidML.VaiCtx ctx, global::PlaidML.PlaidmlDevice device, ulong size)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
            var __ret = __Internal.PlaidmlAllocBuffer(__arg0, __arg1, size);
            global::PlaidML.PlaidmlBuffer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlBuffer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlBuffer) global::PlaidML.PlaidmlBuffer.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlBuffer.__CreateInstance(__ret);
            return __result0;
        }

        public static void PlaidmlFreeBuffer(global::PlaidML.PlaidmlBuffer buffer)
        {
            var __arg0 = ReferenceEquals(buffer, null) ? global::System.IntPtr.Zero : buffer.__Instance;
            __Internal.PlaidmlFreeBuffer(__arg0);
        }

        public static global::PlaidML.PlaidmlMapping PlaidmlMapBufferCurrent(global::PlaidML.PlaidmlBuffer buffer, global::PlaidML.Delegates.Action_IntPtr_IntPtr callback, global::System.IntPtr arg)
        {
            var __arg0 = ReferenceEquals(buffer, null) ? global::System.IntPtr.Zero : buffer.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.PlaidmlMapBufferCurrent(__arg0, __arg1, arg);
            global::PlaidML.PlaidmlMapping __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlMapping.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlMapping) global::PlaidML.PlaidmlMapping.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlMapping.__CreateInstance(__ret);
            return __result0;
        }

        public static global::PlaidML.PlaidmlMapping PlaidmlMapBufferDiscard(global::PlaidML.VaiCtx ctx, global::PlaidML.PlaidmlBuffer buffer)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(buffer, null) ? global::System.IntPtr.Zero : buffer.__Instance;
            var __ret = __Internal.PlaidmlMapBufferDiscard(__arg0, __arg1);
            global::PlaidML.PlaidmlMapping __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlMapping.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlMapping) global::PlaidML.PlaidmlMapping.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlMapping.__CreateInstance(__ret);
            return __result0;
        }

        public static sbyte* PlaidmlGetMappingBase(global::PlaidML.VaiCtx ctx, global::PlaidML.PlaidmlMapping mapping)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(mapping, null) ? global::System.IntPtr.Zero : mapping.__Instance;
            var __ret = __Internal.PlaidmlGetMappingBase(__arg0, __arg1);
            return __ret;
        }

        public static ulong PlaidmlGetMappingSize(global::PlaidML.VaiCtx ctx, global::PlaidML.PlaidmlMapping mapping)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(mapping, null) ? global::System.IntPtr.Zero : mapping.__Instance;
            var __ret = __Internal.PlaidmlGetMappingSize(__arg0, __arg1);
            return __ret;
        }

        public static bool PlaidmlWritebackMapping(global::PlaidML.VaiCtx ctx, global::PlaidML.PlaidmlMapping mapping)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(mapping, null) ? global::System.IntPtr.Zero : mapping.__Instance;
            var __ret = __Internal.PlaidmlWritebackMapping(__arg0, __arg1);
            return __ret;
        }

        public static void PlaidmlFreeMapping(global::PlaidML.PlaidmlMapping mapping)
        {
            var __arg0 = ReferenceEquals(mapping, null) ? global::System.IntPtr.Zero : mapping.__Instance;
            __Internal.PlaidmlFreeMapping(__arg0);
        }

        public static void PlaidmlSetFloatx(global::PlaidML.PlaidmlDatatype datatype)
        {
            __Internal.PlaidmlSetFloatx(datatype);
        }

        public static global::PlaidML.PlaidmlShape PlaidmlAllocShape(global::PlaidML.VaiCtx ctx, global::PlaidML.PlaidmlDatatype datatype)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.PlaidmlAllocShape(__arg0, datatype);
            global::PlaidML.PlaidmlShape __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlShape.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlShape) global::PlaidML.PlaidmlShape.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlShape.__CreateInstance(__ret);
            return __result0;
        }

        public static void PlaidmlFreeShape(global::PlaidML.PlaidmlShape shape)
        {
            var __arg0 = ReferenceEquals(shape, null) ? global::System.IntPtr.Zero : shape.__Instance;
            __Internal.PlaidmlFreeShape(__arg0);
        }

        public static bool PlaidmlSetShapeOffset(global::PlaidML.VaiCtx ctx, global::PlaidML.PlaidmlShape shape, ulong offset_in_elements)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(shape, null) ? global::System.IntPtr.Zero : shape.__Instance;
            var __ret = __Internal.PlaidmlSetShapeOffset(__arg0, __arg1, offset_in_elements);
            return __ret;
        }

        public static bool PlaidmlAddDimension(global::PlaidML.VaiCtx ctx, global::PlaidML.PlaidmlShape shape, ulong size_in_elements, long stride_in_elements)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(shape, null) ? global::System.IntPtr.Zero : shape.__Instance;
            var __ret = __Internal.PlaidmlAddDimension(__arg0, __arg1, size_in_elements, stride_in_elements);
            return __ret;
        }

        public static global::PlaidML.PlaidmlDatatype PlaidmlGetShapeType(global::PlaidML.PlaidmlShape shape)
        {
            var __arg0 = ReferenceEquals(shape, null) ? global::System.IntPtr.Zero : shape.__Instance;
            var __ret = __Internal.PlaidmlGetShapeType(__arg0);
            return __ret;
        }

        public static ulong PlaidmlGetShapeOffset(global::PlaidML.PlaidmlShape shape)
        {
            var __arg0 = ReferenceEquals(shape, null) ? global::System.IntPtr.Zero : shape.__Instance;
            var __ret = __Internal.PlaidmlGetShapeOffset(__arg0);
            return __ret;
        }

        public static ulong PlaidmlGetShapeDimensionCount(global::PlaidML.PlaidmlShape shape)
        {
            var __arg0 = ReferenceEquals(shape, null) ? global::System.IntPtr.Zero : shape.__Instance;
            var __ret = __Internal.PlaidmlGetShapeDimensionCount(__arg0);
            return __ret;
        }

        public static ulong PlaidmlGetShapeDimensionSize(global::PlaidML.PlaidmlShape shape, ulong dim)
        {
            var __arg0 = ReferenceEquals(shape, null) ? global::System.IntPtr.Zero : shape.__Instance;
            var __ret = __Internal.PlaidmlGetShapeDimensionSize(__arg0, dim);
            return __ret;
        }

        public static long PlaidmlGetShapeDimensionStride(global::PlaidML.PlaidmlShape shape, ulong dim)
        {
            var __arg0 = ReferenceEquals(shape, null) ? global::System.IntPtr.Zero : shape.__Instance;
            var __ret = __Internal.PlaidmlGetShapeDimensionStride(__arg0, dim);
            return __ret;
        }

        public static ulong PlaidmlGetShapeBufferSize(global::PlaidML.PlaidmlShape shape)
        {
            var __arg0 = ReferenceEquals(shape, null) ? global::System.IntPtr.Zero : shape.__Instance;
            var __ret = __Internal.PlaidmlGetShapeBufferSize(__arg0);
            return __ret;
        }

        public static ulong PlaidmlGetShapeElementCount(global::PlaidML.PlaidmlShape shape)
        {
            var __arg0 = ReferenceEquals(shape, null) ? global::System.IntPtr.Zero : shape.__Instance;
            var __ret = __Internal.PlaidmlGetShapeElementCount(__arg0);
            return __ret;
        }

        public static void PlaidmlFreeFunction(global::PlaidML.PlaidmlFunction function)
        {
            var __arg0 = ReferenceEquals(function, null) ? global::System.IntPtr.Zero : function.__Instance;
            __Internal.PlaidmlFreeFunction(__arg0);
        }

        public static ulong PlaidmlGetFunctionInputCount(global::PlaidML.PlaidmlFunction function)
        {
            var __arg0 = ReferenceEquals(function, null) ? global::System.IntPtr.Zero : function.__Instance;
            var __ret = __Internal.PlaidmlGetFunctionInputCount(__arg0);
            return __ret;
        }

        public static string PlaidmlGetFunctionInput(global::PlaidML.PlaidmlFunction function, ulong i)
        {
            var __arg0 = ReferenceEquals(function, null) ? global::System.IntPtr.Zero : function.__Instance;
            var __ret = __Internal.PlaidmlGetFunctionInput(__arg0, i);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static ulong PlaidmlGetFunctionOutputCount(global::PlaidML.PlaidmlFunction function)
        {
            var __arg0 = ReferenceEquals(function, null) ? global::System.IntPtr.Zero : function.__Instance;
            var __ret = __Internal.PlaidmlGetFunctionOutputCount(__arg0);
            return __ret;
        }

        public static string PlaidmlGetFunctionOutput(global::PlaidML.PlaidmlFunction function, ulong i)
        {
            var __arg0 = ReferenceEquals(function, null) ? global::System.IntPtr.Zero : function.__Instance;
            var __ret = __Internal.PlaidmlGetFunctionOutput(__arg0, i);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static void PlaidmlFreeVar(global::PlaidML.PlaidmlVar var)
        {
            var __arg0 = ReferenceEquals(var, null) ? global::System.IntPtr.Zero : var.__Instance;
            __Internal.PlaidmlFreeVar(__arg0);
        }

        public static global::PlaidML.PlaidmlVar PlaidmlAllocPlaceholder(ulong num_dimensions)
        {
            var __ret = __Internal.PlaidmlAllocPlaceholder(num_dimensions);
            global::PlaidML.PlaidmlVar __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlVar.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlVar) global::PlaidML.PlaidmlVar.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlVar.__CreateInstance(__ret);
            return __result0;
        }

        public static global::PlaidML.PlaidmlVar PlaidmlAllocInt64(long value)
        {
            var __ret = __Internal.PlaidmlAllocInt64(value);
            global::PlaidML.PlaidmlVar __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlVar.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlVar) global::PlaidML.PlaidmlVar.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlVar.__CreateInstance(__ret);
            return __result0;
        }

        public static global::PlaidML.PlaidmlVar PlaidmlAllocReal(double value)
        {
            var __ret = __Internal.PlaidmlAllocReal(value);
            global::PlaidML.PlaidmlVar __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlVar.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlVar) global::PlaidML.PlaidmlVar.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlVar.__CreateInstance(__ret);
            return __result0;
        }

        public static global::PlaidML.PlaidmlVar PlaidmlAllocTensor(global::PlaidML.VaiCtx ctx, global::PlaidML.PlaidmlBuffer buffer, global::PlaidML.PlaidmlShape shape)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(buffer, null) ? global::System.IntPtr.Zero : buffer.__Instance;
            var __arg2 = ReferenceEquals(shape, null) ? global::System.IntPtr.Zero : shape.__Instance;
            var __ret = __Internal.PlaidmlAllocTensor(__arg0, __arg1, __arg2);
            global::PlaidML.PlaidmlVar __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlVar.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlVar) global::PlaidML.PlaidmlVar.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlVar.__CreateInstance(__ret);
            return __result0;
        }

        public static global::PlaidML.PlaidmlFunction PlaidmlBuildCodedFunction(string code, string id)
        {
            var __ret = __Internal.PlaidmlBuildCodedFunction(code, id);
            global::PlaidML.PlaidmlFunction __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlFunction.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlFunction) global::PlaidML.PlaidmlFunction.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlFunction.__CreateInstance(__ret);
            return __result0;
        }

        public static global::PlaidML.PlaidmlFunction PlaidmlLoadFunction(global::PlaidML.VaiCtx ctx, global::PlaidML.PlaidmlDevice dev, string file)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(dev, null) ? global::System.IntPtr.Zero : dev.__Instance;
            var __ret = __Internal.PlaidmlLoadFunction(__arg0, __arg1, file);
            global::PlaidML.PlaidmlFunction __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlFunction.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlFunction) global::PlaidML.PlaidmlFunction.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlFunction.__CreateInstance(__ret);
            return __result0;
        }

        public static bool PlaidmlSaveFunction(global::PlaidML.PlaidmlFunction func, string file)
        {
            var __arg0 = ReferenceEquals(func, null) ? global::System.IntPtr.Zero : func.__Instance;
            var __ret = __Internal.PlaidmlSaveFunction(__arg0, file);
            return __ret;
        }

        public static global::PlaidML.PlaidmlComposer PlaidmlAllocComposer()
        {
            var __ret = __Internal.PlaidmlAllocComposer();
            global::PlaidML.PlaidmlComposer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlComposer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlComposer) global::PlaidML.PlaidmlComposer.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlComposer.__CreateInstance(__ret);
            return __result0;
        }

        public static bool PlaidmlAddComposerInput(global::PlaidML.PlaidmlComposer composer, string name, global::PlaidML.PlaidmlVar var)
        {
            var __arg0 = ReferenceEquals(composer, null) ? global::System.IntPtr.Zero : composer.__Instance;
            var __arg2 = ReferenceEquals(var, null) ? global::System.IntPtr.Zero : var.__Instance;
            var __ret = __Internal.PlaidmlAddComposerInput(__arg0, name, __arg2);
            return __ret;
        }

        public static bool PlaidmlAddComposerOutput(global::PlaidML.PlaidmlComposer composer, string name, global::PlaidML.PlaidmlVar var)
        {
            var __arg0 = ReferenceEquals(composer, null) ? global::System.IntPtr.Zero : composer.__Instance;
            var __arg2 = ReferenceEquals(var, null) ? global::System.IntPtr.Zero : var.__Instance;
            var __ret = __Internal.PlaidmlAddComposerOutput(__arg0, name, __arg2);
            return __ret;
        }

        public static bool PlaidmlAddComposerDependency(global::PlaidML.PlaidmlComposer composer, global::PlaidML.PlaidmlApplier must_run_before)
        {
            var __arg0 = ReferenceEquals(composer, null) ? global::System.IntPtr.Zero : composer.__Instance;
            var __arg1 = ReferenceEquals(must_run_before, null) ? global::System.IntPtr.Zero : must_run_before.__Instance;
            var __ret = __Internal.PlaidmlAddComposerDependency(__arg0, __arg1);
            return __ret;
        }

        public static bool PlaidmlAddComposerUpdate(global::PlaidML.PlaidmlComposer composer, global::PlaidML.PlaidmlVar dest_tensor, global::PlaidML.PlaidmlVar src_tensor)
        {
            var __arg0 = ReferenceEquals(composer, null) ? global::System.IntPtr.Zero : composer.__Instance;
            var __arg1 = ReferenceEquals(dest_tensor, null) ? global::System.IntPtr.Zero : dest_tensor.__Instance;
            var __arg2 = ReferenceEquals(src_tensor, null) ? global::System.IntPtr.Zero : src_tensor.__Instance;
            var __ret = __Internal.PlaidmlAddComposerUpdate(__arg0, __arg1, __arg2);
            return __ret;
        }

        public static global::PlaidML.PlaidmlFunction PlaidmlBuildComposedFunction(global::PlaidML.PlaidmlComposer composer)
        {
            var __arg0 = ReferenceEquals(composer, null) ? global::System.IntPtr.Zero : composer.__Instance;
            var __ret = __Internal.PlaidmlBuildComposedFunction(__arg0);
            global::PlaidML.PlaidmlFunction __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlFunction.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlFunction) global::PlaidML.PlaidmlFunction.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlFunction.__CreateInstance(__ret);
            return __result0;
        }

        public static void PlaidmlFreeComposer(global::PlaidML.PlaidmlComposer composer)
        {
            var __arg0 = ReferenceEquals(composer, null) ? global::System.IntPtr.Zero : composer.__Instance;
            __Internal.PlaidmlFreeComposer(__arg0);
        }

        public static global::PlaidML.PlaidmlApplier PlaidmlAllocApplier(global::PlaidML.PlaidmlFunction function)
        {
            var __arg0 = ReferenceEquals(function, null) ? global::System.IntPtr.Zero : function.__Instance;
            var __ret = __Internal.PlaidmlAllocApplier(__arg0);
            global::PlaidML.PlaidmlApplier __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlApplier.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlApplier) global::PlaidML.PlaidmlApplier.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlApplier.__CreateInstance(__ret);
            return __result0;
        }

        public static bool PlaidmlApplyAddDependency(global::PlaidML.PlaidmlApplier applier, global::PlaidML.PlaidmlApplier must_run_before)
        {
            var __arg0 = ReferenceEquals(applier, null) ? global::System.IntPtr.Zero : applier.__Instance;
            var __arg1 = ReferenceEquals(must_run_before, null) ? global::System.IntPtr.Zero : must_run_before.__Instance;
            var __ret = __Internal.PlaidmlApplyAddDependency(__arg0, __arg1);
            return __ret;
        }

        public static bool PlaidmlApplyAddInput(global::PlaidML.PlaidmlApplier applier, string name, global::PlaidML.PlaidmlVar var)
        {
            var __arg0 = ReferenceEquals(applier, null) ? global::System.IntPtr.Zero : applier.__Instance;
            var __arg2 = ReferenceEquals(var, null) ? global::System.IntPtr.Zero : var.__Instance;
            var __ret = __Internal.PlaidmlApplyAddInput(__arg0, name, __arg2);
            return __ret;
        }

        public static global::PlaidML.PlaidmlVar PlaidmlApplyAllocOutput(global::PlaidML.PlaidmlApplier applier, string name)
        {
            var __arg0 = ReferenceEquals(applier, null) ? global::System.IntPtr.Zero : applier.__Instance;
            var __ret = __Internal.PlaidmlApplyAllocOutput(__arg0, name);
            global::PlaidML.PlaidmlVar __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlVar.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlVar) global::PlaidML.PlaidmlVar.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlVar.__CreateInstance(__ret);
            return __result0;
        }

        public static void PlaidmlFreeApplier(global::PlaidML.PlaidmlApplier applier)
        {
            var __arg0 = ReferenceEquals(applier, null) ? global::System.IntPtr.Zero : applier.__Instance;
            __Internal.PlaidmlFreeApplier(__arg0);
        }

        public static global::PlaidML.PlaidmlInvoker PlaidmlAllocInvoker(global::PlaidML.VaiCtx ctx, global::PlaidML.PlaidmlFunction function)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(function, null) ? global::System.IntPtr.Zero : function.__Instance;
            var __ret = __Internal.PlaidmlAllocInvoker(__arg0, __arg1);
            global::PlaidML.PlaidmlInvoker __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlInvoker.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlInvoker) global::PlaidML.PlaidmlInvoker.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlInvoker.__CreateInstance(__ret);
            return __result0;
        }

        public static void PlaidmlFreeInvoker(global::PlaidML.PlaidmlInvoker invoker)
        {
            var __arg0 = ReferenceEquals(invoker, null) ? global::System.IntPtr.Zero : invoker.__Instance;
            __Internal.PlaidmlFreeInvoker(__arg0);
        }

        public static bool PlaidmlSetInvokerInput(global::PlaidML.PlaidmlInvoker invoker, string name, global::PlaidML.PlaidmlVar var)
        {
            var __arg0 = ReferenceEquals(invoker, null) ? global::System.IntPtr.Zero : invoker.__Instance;
            var __arg2 = ReferenceEquals(var, null) ? global::System.IntPtr.Zero : var.__Instance;
            var __ret = __Internal.PlaidmlSetInvokerInput(__arg0, name, __arg2);
            return __ret;
        }

        public static global::PlaidML.PlaidmlShape PlaidmlAllocInvokerOutputShape(global::PlaidML.PlaidmlInvoker invoker, string name)
        {
            var __arg0 = ReferenceEquals(invoker, null) ? global::System.IntPtr.Zero : invoker.__Instance;
            var __ret = __Internal.PlaidmlAllocInvokerOutputShape(__arg0, name);
            global::PlaidML.PlaidmlShape __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlShape.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlShape) global::PlaidML.PlaidmlShape.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlShape.__CreateInstance(__ret);
            return __result0;
        }

        public static bool PlaidmlSetInvokerOutput(global::PlaidML.PlaidmlInvoker invoker, string name, global::PlaidML.PlaidmlVar var)
        {
            var __arg0 = ReferenceEquals(invoker, null) ? global::System.IntPtr.Zero : invoker.__Instance;
            var __arg2 = ReferenceEquals(var, null) ? global::System.IntPtr.Zero : var.__Instance;
            var __ret = __Internal.PlaidmlSetInvokerOutput(__arg0, name, __arg2);
            return __ret;
        }

        public static global::PlaidML.PlaidmlInvocation PlaidmlScheduleInvocation(global::PlaidML.VaiCtx ctx, global::PlaidML.PlaidmlInvoker invoker)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(invoker, null) ? global::System.IntPtr.Zero : invoker.__Instance;
            var __ret = __Internal.PlaidmlScheduleInvocation(__arg0, __arg1);
            global::PlaidML.PlaidmlInvocation __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlInvocation.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlInvocation) global::PlaidML.PlaidmlInvocation.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlInvocation.__CreateInstance(__ret);
            return __result0;
        }

        public static void PlaidmlFreeInvocation(global::PlaidML.PlaidmlInvocation invocation)
        {
            var __arg0 = ReferenceEquals(invocation, null) ? global::System.IntPtr.Zero : invocation.__Instance;
            __Internal.PlaidmlFreeInvocation(__arg0);
        }

        public static global::PlaidML.PlaidmlGradient PlaidmlAllocGradient(global::PlaidML.PlaidmlVar var)
        {
            var __arg0 = ReferenceEquals(var, null) ? global::System.IntPtr.Zero : var.__Instance;
            var __ret = __Internal.PlaidmlAllocGradient(__arg0);
            global::PlaidML.PlaidmlGradient __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlGradient.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlGradient) global::PlaidML.PlaidmlGradient.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlGradient.__CreateInstance(__ret);
            return __result0;
        }

        public static void PlaidmlFreeGradient(global::PlaidML.PlaidmlGradient grad)
        {
            var __arg0 = ReferenceEquals(grad, null) ? global::System.IntPtr.Zero : grad.__Instance;
            __Internal.PlaidmlFreeGradient(__arg0);
        }

        public static global::PlaidML.PlaidmlVar PlaidmlComputeGradWrt(global::PlaidML.PlaidmlGradient grad, global::PlaidML.PlaidmlVar wrt)
        {
            var __arg0 = ReferenceEquals(grad, null) ? global::System.IntPtr.Zero : grad.__Instance;
            var __arg1 = ReferenceEquals(wrt, null) ? global::System.IntPtr.Zero : wrt.__Instance;
            var __ret = __Internal.PlaidmlComputeGradWrt(__arg0, __arg1);
            global::PlaidML.PlaidmlVar __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PlaidML.PlaidmlVar.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PlaidML.PlaidmlVar) global::PlaidML.PlaidmlVar.NativeToManagedMap[__ret];
            else __result0 = global::PlaidML.PlaidmlVar.__CreateInstance(__ret);
            return __result0;
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_PlaidML_vai_log_severity_string(global::System.IntPtr _0, global::PlaidML.VaiLogSeverity _1, [MarshalAs(UnmanagedType.LPStr)] string _2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_IntPtr(global::System.IntPtr _0, global::System.IntPtr _1);
    }
}
